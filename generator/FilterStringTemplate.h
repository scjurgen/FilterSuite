
/**
 * Autogenerated filter __FILTERNAME__
 * DO NOT CHANGE MANUALLY
 */
template <typename _CalcType_>
class __FILTERNAME__ : public GenericFilter<_CalcType_>
{
  public:
    __FILTERNAME__(FILTERCHARACTER fc__EXTRAPARAMETER__)
        : filterCoefficients(__PASSMODE__, fc, __ORDER____EXTRAPARAMETERPASS__)
    {
        reset();
    }

    void reset(void)
    {
        for (size_t i = 0; i < __DELAYELEMENTS__; ++i) { v[i] = 0; }
    }

    void setAlphas(double alphaLow, double alphaHigh) override
    {
        filterCoefficients.computeFilter(alphaLow, alphaHigh);
        setFilterParameters(1.0 / filterCoefficients.rGain, filterCoefficients.xcoeffs, filterCoefficients.ycoeffs);
    }

    void setAlpha(double alphaLow) override
    {
        setAlphas(alphaLow, alphaLow);
    }

    void setChebyshevRipple(double ripple)
    {
        filterCoefficients.chebyshevRipple = ripple;
    }

    void setQfactor(double q)
    {
        filterCoefficients.qfactor = q;
    }

    void inline shiftChain()
    {
        for (size_t j = 0; j < __DELAYELEMENTSM1__; ++j) { v[j] = v[j + 1]; }
    }
    /** do not use in more than 1 call */
    _CalcType_ step(_CalcType_ x) override
    {
        shiftChain();
        v[__DELAYELEMENTSM1__] = gain * x __YCHAIN__;
        return __XCHAIN__;
    }

    void setFilterParameters(_CalcType_ gain, const std::vector<_CalcType_>& xcoeffs,
                             const std::vector<_CalcType_>& ycoeffs)
    {
        this->gain = gain;
        for (size_t i = 0; i < __DELAYELEMENTSM1__; ++i) { this->xcoeffs[i] = xcoeffs[i]; }
        for (size_t i = 0; i < __DELAYELEMENTSM1__; ++i) { this->ycoeffs[i] = ycoeffs[i]; }
    }
    void setFilterParameters(const FilterCoefficients& fc)
    {
        setFilterParameters(1.0 / fc.rGain, fc.xcoeffs, fc.ycoeffs);
    }

  private:
    _CalcType_         gain;
    _CalcType_         xcoeffs[__DELAYELEMENTSM1__];
    _CalcType_         ycoeffs[__DELAYELEMENTSM1__];
    _CalcType_         v[__DELAYELEMENTS__];
    FilterCoefficients filterCoefficients;
};
